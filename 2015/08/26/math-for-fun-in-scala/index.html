<!DOCTYPE html>
<html>
  <head>
    <!-- meta information -->
<meta charset="utf-8">
<meta name="description" 
      content="#### 缘起刚用Scala做了一个像样的[项目](http://xun.im/2015/08/24/weixin-robot-vs-kindle-2.0/)，对Scala热情满满，无事时用它做了几题Project Euler， 发现..." >
<meta name="author" content="wuhx">

<!-- Enable responsiveness on mobile devices-->
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

<!-- title -->
<title>数学的乐趣：Scala和Project Euler &middot; Not my idea</title>

<!-- icons -->
<link rel="shortcut icon" href="/public/images/favicon.ico" />

<!-- stylesheets -->
<link rel="stylesheet" href="/public/css/responsive.gs.12col.css">
<link rel="stylesheet" href="/public/css/animate.min.css">
<link rel="stylesheet" href="/public/css/main.css">

<!-- Google fonts -->
<link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Source+Sans+Pro:400,700,400italic&subset=latin-ext">



<!-- feed links -->
<link rel="alternate" href="xun.im/feed.xml" type="application/rss+xml" title="">

  </head>
  <body>
    <div class="container azul">
      <header class="top row gutters">
        <div class="col span_2 center">
          <!-- TODO: add baseurl to the logo link -->
          <a href="xun.im" id="logo" title="Not my idea"
             style="background-image: url(/public/images/logo.png);"></a>
        </div>
        <nav class="col span_10 top-navbar">
  
  <a href="/" title="Home"
     >Home</a>
  
  <a href="/about" title="About"
     >About</a>
  
</nav>

      </header>

      <article class="single row gutters">
  <time class="published" datetime="2015-08-26">26 August 2015</time>
  <h2>数学的乐趣：Scala和Project Euler</h2>

  <h4 id="section">缘起</h4>

<p>刚用Scala做了一个像样的<a href="http://xun.im/2015/08/24/weixin-robot-vs-kindle-2.0/">项目</a>，对Scala热情满满，无事时用它做了几题Project Euler， 发现Scala非常适合这个，写一点心得，希望抛砖引玉，能有更多的人喜欢上Scala这门语言。</p>

<h3 id="section-1">从第12题说起</h3>

<p>Problem 12 ：<a href="http://projecteuler.net/index.php?section=problems&amp;id=12">Highly divisible triangular number</a></p>

<p>The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:</p>

<p>1, 3, 6, 10, 15, 21, 28, 36, 45, 55, …</p>

<p>Let us list the factors of the first seven triangle numbers:</p>

<blockquote>
  <p><strong> 1</strong>: 1</p>

  <p><strong> 3</strong>: 1,3</p>

  <p><strong> 6</strong>: 1,2,3,6</p>

  <p><strong>10</strong>: 1,2,5,10</p>

  <p><strong>15</strong>: 1,3,5,15</p>

  <p><strong>21</strong>: 1,3,7,21</p>

  <p><strong>28</strong>: 1,2,4,7,14,28</p>
</blockquote>

<p>We can see that 28 is the first triangle number to have over five divisors.</p>

<p>What is the value of the first triangle number to have over five hundred divisors?</p>

<h3 id="section-2">快速实现</h3>

<p>根据题目描述，所谓triangle数，是指第n个数为1到n相加得出的数。需要求出第一个有500个因子的triangle数。所以解题需要两步：</p>

<ol>
  <li>找出所有的triangle数。</li>
  <li>计算每个triangle的因子，找出第一个因子数大于500的triangle数。</li>
</ol>

<p>简单！</p>

<h4 id="triangular">triangular数的定义</h4>

<p>triangular数按定义最直接的实现。</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">def</span> <span class="n">triangulars</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">n</span> <span class="k">match</span> <span class="o">{</span>
 <span class="k">case</span> <span class="mi">1</span> <span class="k">=&gt;</span> <span class="mi">1</span>
 <span class="k">case</span> <span class="n">num</span> <span class="k">=&gt;</span> <span class="n">triangulars</span><span class="o">(</span><span class="n">num</span><span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">+</span> <span class="n">num</span>
<span class="o">}</span>
</code></pre>
</div>

<p>如果是第一个数返回1，否则返回前一个triangular数和n之和，递归实现。</p>

<h4 id="section-3">检查因子数：</h4>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">def</span> <span class="n">divisisorsNum</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
  <span class="o">(</span><span class="mi">1</span> <span class="n">to</span> <span class="n">n</span><span class="o">).</span><span class="n">filter</span><span class="o">(</span> <span class="n">n</span> <span class="o">%</span> <span class="k">_</span> <span class="o">==</span> <span class="mi">0</span><span class="o">).</span><span class="n">size</span> 
<span class="o">}</span>
</code></pre>
</div>

<p>n和所有小于n的数取模，并统计能被整除（取模结果为0）的数的个数，即为n的因子数。</p>

<h4 id="ntriangle-">获取最小有n个因子的triangle 数：</h4>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">def</span> <span class="n">euler12</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
  <span class="nc">Stream</span><span class="o">.</span><span class="n">from</span><span class="o">(</span><span class="mi">1</span><span class="o">).</span><span class="n">map</span><span class="o">(</span><span class="n">triangulars</span><span class="o">).</span><span class="n">find</span><span class="o">(</span><span class="n">divisisorsNum</span><span class="o">(</span><span class="k">_</span><span class="o">)</span> <span class="o">&gt;</span> <span class="n">n</span><span class="o">)</span>
<span class="o">}</span>
</code></pre>
</div>

<p><code class="highlighter-rouge">Stream.from(1)</code>构建一个从1开始的整数列表，像整数的定义一样，这个列表是无穷大的，但其中的值在被引用之前并不存在于内存中，而是通过call by name实现惰性求值。可以理解为该列表是由一个head元素+动态计算出后续元素的函数组成。</p>

<p>通过对整数列表执行triangulars函数的map，生成一个triangular数组成的列表，同样，这个列表也是无穷大和惰性求值的。</p>

<p>最后查找其中divisisorsNum也就是因子数大于n的第一个triangular数。</p>

<h4 id="section-4">运行：</h4>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="n">euler12</span><span class="o">(</span><span class="mi">5</span><span class="o">)</span>
<span class="n">res4</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">28</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">euler12</span><span class="o">(</span><span class="mi">50</span><span class="o">)</span>
<span class="n">res5</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">25200</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">euler12</span><span class="o">(</span><span class="mi">500</span><span class="o">)</span>
</code></pre>
</div>

<p>因子数较小的测试都没有问题，但在求本题的答案时（500个因子）挂死，原因是我们的程序效率太低，CPU算不过来了。</p>

<h3 id="section-5">改进</h3>

<h4 id="section-6">尾递归</h4>

<p>首先triangulars函数中，我们用到了递归，但不是尾递归，如若递归层数太深，会发生栈溢出。</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="n">triangulars</span><span class="o">(</span><span class="nc">Int</span><span class="o">.</span><span class="nc">MaxValue</span><span class="o">)</span>
<span class="n">java</span><span class="o">.</span><span class="n">lang</span><span class="o">.</span><span class="nc">StackOverflowError</span>
  <span class="n">at</span> <span class="o">.</span><span class="n">triangulars</span><span class="o">(&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">12</span><span class="o">)</span>
  <span class="n">at</span> <span class="o">.</span><span class="n">triangulars</span><span class="o">(&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">12</span><span class="o">)</span>
  <span class="n">at</span> <span class="o">.</span><span class="n">triangulars</span><span class="o">(&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">12</span><span class="o">)</span>
</code></pre>
</div>

<p>改成尾递归</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="nd">@tailrec</span>
<span class="k">def</span> <span class="n">triangulars</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Long</span><span class="o">,</span> <span class="n">acc</span><span class="k">:</span> <span class="kt">Long</span> <span class="o">=</span> <span class="mi">1</span><span class="o">)</span><span class="k">:</span> <span class="kt">Long</span> <span class="o">=</span> <span class="n">n</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="mi">1</span> <span class="k">=&gt;</span> <span class="n">acc</span>
  <span class="k">case</span> <span class="n">num</span> <span class="k">=&gt;</span> <span class="n">triangulars</span><span class="o">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="n">acc</span> <span class="o">+</span> <span class="n">n</span><span class="o">)</span>
<span class="o">}</span>
</code></pre>
</div>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="n">triangulars</span><span class="o">(</span><span class="nc">Int</span><span class="o">.</span><span class="nc">MaxValue</span><span class="o">)</span>
<span class="n">res2</span><span class="k">:</span> <span class="kt">Long</span> <span class="o">=</span> <span class="mi">2305843008139952128</span>
</code></pre>
</div>

<p>但改完后求本题答案还是挂死（其实跑几个小时还是能算出答案的），仔细观察，euler12获取triangular数列表的效率非常低，反复的对每个整数计算对应的triangular数，而这些计算有很大一部分是重复的，如triangulars(100)，其实就是triangulars(99)+100，不需要从1开始重新计算。</p>

<p>所以需要</p>

<h4 id="triangular-1">更高效的构建triangular数列表</h4>

<p>稍加推导，除第一个元素，第n个triangular数是前一个triangular数和n之和，直接用这个定义构成triangular数列表。</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">def</span> <span class="n">triangulars</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">Int</span><span class="o">=</span><span class="mi">1</span><span class="o">,</span> <span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">=</span><span class="mi">2</span><span class="o">)</span><span class="k">:</span> <span class="kt">Stream</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="n">a</span> <span class="o">#::</span> <span class="n">triangulars</span><span class="o">(</span><span class="n">a</span><span class="o">+</span><span class="n">n</span><span class="o">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="o">)</span>
</code></pre>
</div>

<p>新的triangulars函数直接生成一个Stream，第一个参数作为递归的初始值，第二个参数标记index，每次递归时加1。</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="n">triangulars</span><span class="o">().</span><span class="n">take</span><span class="o">(</span><span class="mi">10</span><span class="o">).</span><span class="n">force</span>
<span class="n">res6</span><span class="k">:</span> <span class="kt">scala.collection.immutable.Stream</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Stream</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">10</span><span class="o">,</span> <span class="mi">15</span><span class="o">,</span> <span class="mi">21</span><span class="o">,</span> <span class="mi">28</span><span class="o">,</span> <span class="mi">36</span><span class="o">,</span> <span class="mi">45</span><span class="o">,</span> <span class="mi">55</span><span class="o">)</span>
</code></pre>
</div>

<p>作为测试，从这个列表中取出10个数，并强制求值，查看结果。</p>

<h4 id="section-7">更高效的检查因子数</h4>

<p>前面的<code class="highlighter-rouge">divisisorsNum</code>函数检查因子数的方法是把n和所有小于n的整数都取模，过滤出其中能被除尽的数，这样效率显然太低了，尤其是取模运算很耗CPU。</p>

<p>更高效的方法是：只检查小于根号n的数，并将结果乘以2（每个能整除的因子必然还有一个大于根号n小于n的同伴）。</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">def</span> <span class="n">divisisorNumbers</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
  <span class="nc">Stream</span><span class="o">.</span><span class="n">from</span><span class="o">(</span><span class="mi">1</span><span class="o">).</span><span class="n">takeWhile</span><span class="o">(</span><span class="n">i</span> <span class="k">=&gt;</span> <span class="n">i</span><span class="o">*</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">)</span>
    <span class="o">.</span><span class="n">foldLeft</span><span class="o">(</span><span class="mi">0</span><span class="o">)((</span><span class="n">acc</span><span class="o">,</span> <span class="n">i</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">%</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="n">acc</span> <span class="o">+</span> <span class="mi">2</span> <span class="k">else</span> <span class="n">acc</span><span class="o">)</span>
<span class="o">}</span>
</code></pre>
</div>

<p>这里用到了foldLeft，其作用是把Stream中所有的元素过一遍指定的函数，并将结果累加返回。</p>

<p><code class="highlighter-rouge">foldLeft(0)((acc, i) =&gt; if (n % i == 0) acc + 2 else acc)</code> 第一个参数0是累加器的初始值，acc是累加器，i为Stream中的各个元素。</p>

<h4 id="section-8">改进后的版本：</h4>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">def</span> <span class="n">euler12</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
  <span class="n">triangulars</span><span class="o">().</span><span class="n">find</span><span class="o">(</span><span class="n">divisisorNumbers</span><span class="o">(</span><span class="k">_</span><span class="o">)</span> <span class="o">&gt;</span> <span class="n">n</span><span class="o">)</span>
<span class="o">}</span>
</code></pre>
</div>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="n">euler12</span><span class="o">(</span><span class="mi">500</span><span class="o">)</span>
<span class="n">res21</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="mi">76576500</span><span class="o">)</span>
</code></pre>
</div>

<p>统计一下时间，花了4秒多得出结果。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>scala&gt; time {euler12(500)}
4 seconds 433 microseconds 155 milliseconds
res24: Option[Int] = Some(76576500)
</code></pre>
</div>

<p>已经到了可用级别了。但是:</p>

<h3 id="section-9">能否更快</h3>

<p>由<a href="http://primes.utm.edu/glossary/xpage/tau.html">数论的知识</a>，任何一个整数都能唯一的表示为几个素数的乘积。</p>

<script type="math/tex; mode=display">n = p_1^{e_1}p_2^{e_2}\cdots p_s^{e^s}\quad</script>

<p>其中n为任意整数，p1-ps为素数。</p>

<p>如，4200可以表示成：</p>

<script type="math/tex; mode=display">4200 = 2^{3}3^{1}5^{2}7^1</script>

<p>所以4200有 (3+1)(1+1)(2+1)(1+1) = 48个因子。</p>

<p>而triangle数可以表示为：</p>

<script type="math/tex; mode=display">triangles(n)=1+2+\cdots+n=\sum_{i=1}^n=\frac{n(n+1)}{2}.</script>

<p>所以triangles(n)的因子数为：n的因子数乘以n+1的因子数，其中n或者n+1中偶数那个因子需要减掉一个因子(因为要除了2)，而n和n+1中必然有一个偶数。</p>

<h4 id="section-10">代码实现</h4>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="cm">/*
* 计算number的因子个数，排除一次2因子
* */</span>
<span class="k">def</span> <span class="n">dns</span><span class="o">(</span><span class="n">number</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">sum</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">primes</span><span class="k">:</span> <span class="kt">Stream</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">primes</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="n">head</span> <span class="o">#::</span> <span class="n">tail</span> <span class="k">if</span> <span class="n">head</span> <span class="o">&gt;</span> <span class="n">number</span> <span class="k">=&gt;</span> <span class="n">sum</span>
  <span class="k">case</span> <span class="n">prime</span> <span class="o">#::</span> <span class="n">tail</span> <span class="k">=&gt;</span>
    <span class="k">var</span> <span class="n">n</span> <span class="k">=</span> <span class="n">number</span>
    <span class="k">var</span> <span class="n">count</span> <span class="k">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">n</span> <span class="o">%</span> <span class="n">prime</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">n</span> <span class="k">=</span> <span class="n">n</span> <span class="o">/</span> <span class="n">prime</span>
      <span class="n">count</span> <span class="k">=</span> <span class="n">count</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="o">}</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">prime</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">&amp;&amp;</span> <span class="n">count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">count</span> <span class="k">=</span> <span class="n">count</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="o">}</span>
    <span class="n">dns</span><span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="n">sum</span> <span class="o">*</span> <span class="o">(</span><span class="n">count</span> <span class="o">+</span> <span class="mi">1</span><span class="o">),</span> <span class="n">tail</span><span class="o">)</span>
<span class="o">}</span>
<span class="k">def</span> <span class="n">euler12</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">primeStreamInt</span> <span class="k">=</span> <span class="nc">Stream</span><span class="o">.</span><span class="n">from</span><span class="o">(</span><span class="mi">1</span><span class="o">).</span><span class="n">filter</span><span class="o">(</span><span class="nc">BigInt</span><span class="o">(</span><span class="k">_</span><span class="o">).</span><span class="n">isProbablePrime</span><span class="o">(</span><span class="mi">15</span><span class="o">))</span>
  <span class="nc">Stream</span><span class="o">.</span><span class="n">from</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
    <span class="o">.</span><span class="n">find</span><span class="o">(</span><span class="n">i</span> <span class="k">=&gt;</span> <span class="n">dns</span><span class="o">(</span><span class="n">i</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span> <span class="n">primeStreamInt</span><span class="o">)</span> <span class="o">*</span> <span class="n">dns</span><span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span><span class="n">primeStreamInt</span><span class="o">)</span> <span class="o">&gt;</span> <span class="n">n</span><span class="o">)</span>
    <span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">i</span> <span class="k">=&gt;</span> <span class="n">i</span> <span class="o">*</span> <span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">)</span>
<span class="o">}</span>
</code></pre>
</div>

<p>代码中用到的primeStreamInt是利用JDK的isProbablePrime函数过滤出的素数列表，用于查找因子，算是一个小cheat。</p>

<p>统计时间：性能提高到了毫秒级，但是我还是更喜欢前面那个4秒多的实现：）</p>

<div class="highlighter-rouge"><pre class="highlight"><code>scala&gt; time(euler12(500))
0 seconds 156 microseconds 568 milliseconds
res6: Option[Int] = Some(76576500)
</code></pre>
</div>

<h3 id="section-11">结语</h3>

<p>Scala是一门很有趣的语言，同时具有函数式语言的活泼和Java生态系统的严谨。如果你还有学习的动力，把它作为你的下一门语言吧。</p>


	
	<!-- duoshuo box -->
	<div class="ds-thread" data-thread-key="/2015/08/26/math-for-fun-in-scala" data-title="数学的乐趣：Scala和Project Euler" data-url="xun.im/2015/08/26/math-for-fun-in-scala/"></div>
	<!-- duoshuo box end -->
	
</article>


      <footer>
        <p>
          This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/2.5/deed.zh">署名-非商业性使用-禁止演绎 </a>License.
        </p>
      </footer>
    </div>

    <!-- scripts -->
		<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
		
	<link rel="stylesheet" href="/public/css/tomorrow.css">
	<script src="/public/js/highlight.pack.js"></script>
	<script>hljs.initHighlightingOnLoad();</script>
	
    <script src="/public/js/jquery.min.js"></script>
    <script src="/public/js/jquery.fitvids.js"></script>
    <script>
      $(document).ready(function(){
        $("article").fitVids();
      });
    </script>
		
		<!-- google analystics for xun.im -->
		<script>
		  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
		  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
		  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
		  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
		  ga('create', 'UA-61979906-1', 'auto');
		  ga('send', 'pageview');
		</script>
		<!-- baidu site for xun.im -->
		<script>
		var _hmt = _hmt || [];
		(function() {
		  var hm = document.createElement("script");
		  hm.src = "//hm.baidu.com/hm.js?b62786d99652b034add78b003086816f";
		  var s = document.getElementsByTagName("script")[0]; 
		  s.parentNode.insertBefore(hm, s);
		})();
		</script>
		<!-- duoshuo common -->
		<script type="text/javascript">
		var duoshuoQuery = {short_name:"5site"};
			(function() {
				var ds = document.createElement('script');
				ds.type = 'text/javascript';ds.async = true;
				ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
				ds.charset = 'UTF-8';
				(document.getElementsByTagName('head')[0] 
				 || document.getElementsByTagName('body')[0]).appendChild(ds);
			})();
			</script>
		<!-- duoshuo end -->
		
		
  </body>
</html>
