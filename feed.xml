<?xml version="1.0"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Not my idea</title>
    <link>xun.im</link>
    <atom:link href="xun.im/feed.xml" rel="self" type="application/rss+xml" />
    <description>personal blog, scala, akka,</description>
    <language>en-us</language>
    <pubDate>Fri, 24 Apr 2015 10:50:42 +0800</pubDate>
    <lastBuildDate>Fri, 24 Apr 2015 10:50:42 +0800</lastBuildDate>

    
      <item>
        <title>scala的implicit和magnet模式</title>
        <link>xun.im/2015/04/21/scala-implicit-and-magnet-pattern/</link>
        <pubDate>Tue, 21 Apr 2015 00:00:00 +0800</pubDate>
        <author>wuhx</author>
        <description>&lt;p&gt;对初学scala的人，implicit像一个黑魔法，来无影去无踪，像它的名字一样非常“含蓄”。&lt;/p&gt;

&lt;p&gt;从某种意义上讲，implicit是一个类型系统的游戏。scala是强类型系统，所有的参数都需要符合类型预期，如果需要一个Int类型，你传来一个String，编译器会报类型不符错误。implicit的引入，使在报错之前还有一次机会，即：如果编译器在当前作用域内找到一个从String转换到Int的implicit定义函数，编译器会用这个implicit把你传给它的String转换成它需要的Int，于是一切又愉快的发生下去了。&lt;/p&gt;

&lt;p&gt;当然这只是implicit的一种使用场景，spray.io（已合并到akka-http）的magnet模式利用的就是这个特性。&lt;/p&gt;

&lt;h2&gt;magnet模式&lt;/h2&gt;

&lt;p&gt;magnet模式简单讲就是通过定义一个magnet类型作为统一的参数，然后针对需要重载的参数列表，类型等，在magnet类型的companion object中实现相应的转换为magnet类型的implitcit函数。&lt;/p&gt;

&lt;p&gt;如：可以定义一个Magnet类型实现一个接受任意参数的add函数&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;def add(magnet: MyMagnet): magnet.Result = magnet()

sealed trait MyMagnet {
  type Result
  def apply(): Result
}

object MyMagnet {
  //一个整形参数到MyMagenet的转换
  implicit def fromInt(i: Int) =
    new MyMagnet {
      type Result = Int
      def apply(): Result = i + 1
    }
  //一个String参数到MyMagenet的转换
  implicit def fromString(s: String) =
    new MyMagnet {
      type Result = String
      def apply(): Result = &amp;quot;hello &amp;quot; + s
    }
  //一个String参数加一个整形参数到MyMagenet的转换
  implicit def fromStringAndInt(tuple: (String, Int)) =
    new MyMagnet {
      type Result = String
      def apply(): Result = tuple._1 + tuple._2.toString
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;调用的时候可以：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;scala&amp;gt; add(1)
res9: Int = 2

scala&amp;gt; add(&amp;quot;world&amp;quot;)
res10: String = hello world

scala&amp;gt; add(&amp;quot;happy string &amp;quot;, 5)
res11: String = happy string 5
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;看到这里，你可能会说这不就是重载吗？java和scala原生就支持重载，但jvm对泛型（generics）的支持是通过类型擦除（type erasure）实现的，这意味着java常规的重载无法带类型参数，如：jvm无法区分下面这种类型不同的List参数。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;scala&amp;gt; :paste
// Entering paste mode (ctrl-D to finish)

def add(a: List[Int]): Unit = {}
def add(a: List[String]): Unit = {}

// Exiting paste mode, now interpreting.

&amp;lt;console&amp;gt;:8: error: double definition:
def add(a: List[Int]): Unit at line 7 and
def add(a: List[String]): Unit at line 8
have same type after erasure: (a: List)Unit
def add(a: List[String]): Unit = {}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;而magnet模式正好可以弥补这个缺憾，另外magnet模式相当于把重载的实现从语言层面拉到了自己的代码逻辑中，有利于针对性的引入一些新技巧减少冗余代码。当然，magnet的缺点也是很明显的：额外的一层增加了代码的复杂度。&lt;/p&gt;

&lt;h3&gt;隐含参数&lt;/h3&gt;

&lt;p&gt;implicit另外一个常用的场景是： 替代全局变量，作为某个执行上下文中的隐含参数。&lt;/p&gt;

&lt;p&gt;如：scala中异步的一个重要方法是使用Future。Futrure语义清晰，使用优雅，比手动起线程不知道高到哪里去了；），但Future在后台其实还是通过线程来执行的，要用Future就需要一个指定的执行上下文环境（&lt;a href=&quot;http://www.scala-lang.org/api/2.11.6/index.html#scala.concurrent.ExecutionContext&quot;&gt;ExecutionContext&lt;/a&gt; ，一般是线程池）来跑Future。Future又是一个object（单例对象，不是普通类）没有地方放这个线程池的引用，解决方案只能是在所有Future的方法中加上ExecutionContext参数，方法很函数式，但接口略显冗余。好在scala有implicit，只要你调用Future时，上下文中有一个implicit的ExecutionContext变量，Future会自动在这个EC上跑代码。&lt;/p&gt;

&lt;p&gt;所以scala的&lt;a href=&quot;http://www.scala-lang.org/files/archive/nightly/docs/library/index.html#scala.concurrent.Future&quot;&gt;Future&lt;/a&gt;方法都有一个(implicit executor: ExecutionContext)参数&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;def onComplete(U ⇒ U)(implicit executor: ExecutionContext): Unit
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;不同于全局变量，你在调用Future方法时，想使用某个指定的ExecutionContext，还是可以把它作为参数显示的传递给Future方法，这个显示传递的参数会覆盖implicit的参数。&lt;/p&gt;

&lt;p&gt;另：ExecutionContext的获取方法有&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;直接引用全局EC。&lt;code&gt;import scala.concurrent.ExecutionContext.Implicits.global&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;akka的actor中，引用当前actor系统的EC。&lt;code&gt;import context.dispatcher&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;也可以手动创建一个独占使用，确保线程池里的线程不会被其他不相干任务耗尽。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;   import java.util.concurrent.Executors
   import concurrent.ExecutionContext
   //创建一个4个线程的线程池
   val executorService = Executors.newFixedThreadPool(4)
   implicit val ec = ExecutionContext.fromExecutorService(executorService)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;更多相关资料：&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://spray.io/blog/2012-12-13-the-magnet-pattern/&quot;&gt;The magnet pattern&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://pavelfatin.com/design-patterns-in-scala/&quot;&gt;Design Patterns in Scala&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://eed3si9n.com/revisiting-implicits-without-import-tax&quot;&gt;revisiting implicits without import tax&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.artima.com/pins1ed/implicit-conversions-and-parameters.html&quot;&gt;Chapter 21 of Programming in Scala, First Edition&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://ropas.snu.ac.kr/%7Ebruno/papers/TypeClasses.pdf&quot;&gt;Type Classes as Objects and Implicits&lt;/a&gt; &lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>AKKA的日志： slf4j，logback和其他</title>
        <link>xun.im/2015/04/15/akka-logging/</link>
        <pubDate>Wed, 15 Apr 2015 00:00:00 +0800</pubDate>
        <author>wuhx</author>
        <description>&lt;p&gt;作为一个“搞kernel的”，对日志的理解不过是printk的EMERG,INFO,DEBUG等各种level，关键时刻还是得dump内存，上gcc单步跟踪。但在到处是异步并发，远程分布式通信的jdk世界，日志成了定位问题最重要甚至是唯一的手段。在akka上尤为如此。&lt;/p&gt;

&lt;p&gt;akka日志的官方文档&lt;a href=&quot;http://doc.akka.io/docs/akka/current/scala/logging.html&quot;&gt;http://doc.akka.io/docs/akka/current/scala/logging.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;akka日志功能是基于slf4j构建的。对于不熟悉java的人，slf4j，log4j，logback等基本上是这样一个关系：SLF4J是一套log接口，java.util.logging, logback, log4j等是具体的实现，而logback已逐渐取代log4j成为事实标准。&lt;/p&gt;

&lt;p&gt;所以要使用akka的日志，除了akka-slf4j还需增加logback依赖。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;libraryDependencies ++= Seq(
  &amp;quot;com.typesafe.akka&amp;quot; %% &amp;quot;akka-actor&amp;quot; % akkaVersion,
  &amp;quot;com.typesafe.akka&amp;quot; %% &amp;quot;akka-contrib&amp;quot; % akkaVersion,
  &amp;quot;com.typesafe.akka&amp;quot; %% &amp;quot;akka-testkit&amp;quot; % akkaVersion,
  &amp;quot;com.typesafe.akka&amp;quot; %% &amp;quot;akka-slf4j&amp;quot; % akkaVersion,
  &amp;quot;org.scalatest&amp;quot; %% &amp;quot;scalatest&amp;quot; % &amp;quot;2.2.4&amp;quot; % &amp;quot;test&amp;quot;,
  &amp;quot;ch.qos.logback&amp;quot; % &amp;quot;logback-classic&amp;quot; % &amp;quot;1.1.3&amp;quot;,
  &amp;quot;commons-io&amp;quot; % &amp;quot;commons-io&amp;quot; % &amp;quot;2.4&amp;quot; % &amp;quot;test&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;actor系统中记录日志的三种方法&lt;/h2&gt;

&lt;h3&gt;1 通过ActorLogging记录日志&lt;/h3&gt;

&lt;p&gt;akka提供了ActorLogging这个trait，方便在actor中记录日志。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;class MasterActor extends Actor with akka.actor.ActorLogging{
  def receive = {
    case _ =&amp;gt;
     log.debug(&amp;quot;debug log&amp;quot;)
     log.info(&amp;quot;info log&amp;quot;)
     log.warning(&amp;quot;warning log&amp;quot;)
     log.error(&amp;quot;error log&amp;quot;)
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;2 通过akka.event.Logging记录日志　&lt;/h3&gt;

&lt;p&gt;ActorLogging这个trait只能mix到Actor类上。&lt;/p&gt;

&lt;p&gt;在其他非actor类上，如果能访问到actor系统，可利用它的event stream进行log。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;import akka.event.Logging
val log = Logging(system.eventStream, &amp;quot;log prefix:&amp;quot;)
log.debug(&amp;quot;debug log&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3 直接通过slf4j访问logback记录日志&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;import org.slf4j.LoggerFactory
val log = LoggerFactory.getLogger(getClass)
log.debug(&amp;quot;Hello Logger!&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这3种log方式因为用的都是同一个logback实例，所以输出是统一的，区别是akka提供的log接口能够在记录时自动带上actor地址等信息，能极大的方便定位问题。&lt;/p&gt;

&lt;h2&gt;logback的配置&lt;/h2&gt;

&lt;p&gt;上面说了半天好像和printk的level级别没有太大差别，java的log系统最强大的地方在于它的可配置性。&lt;/p&gt;

&lt;p&gt;如下面这个logback配置，可把ERROR及以上级别的打印输出到akka.log文件，同时把DEBUG及以上级别的打印输出到控制台。还可以配置输出格式，自动在log内容上附带一些上下文信息，如&lt;code&gt;%X{akkaSource}&lt;/code&gt;这个变量会解析为发起log的具体actor地址，这在系统上百万actor并发时，将成为跟踪问题重要线索。如果输出到日志文件，还可控制文件体积的最大值，选择原有内容是追加还是覆盖。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-xml&quot; data-lang=&quot;xml&quot;&gt;&amp;lt;configuration&amp;gt;
        &amp;lt;appender name=&amp;quot;FILE&amp;quot; class=&amp;quot;ch.qos.logback.core.FileAppender&amp;quot;&amp;gt;
        &amp;lt;file&amp;gt;akka.log&amp;lt;/file&amp;gt;
        &amp;lt;filter class=&amp;quot;ch.qos.logback.classic.filter.ThresholdFilter&amp;quot;&amp;gt;
            &amp;lt;level&amp;gt;ERROR&amp;lt;/level&amp;gt;
        &amp;lt;/filter&amp;gt;
        &amp;lt;append&amp;gt;false&amp;lt;/append&amp;gt;
        &amp;lt;!-- encoders are assigned the type
             ch.qos.logback.classic.encoder.PatternLayoutEncoder by default --&amp;gt;
        &amp;lt;encoder&amp;gt;
            &amp;lt;!--&amp;lt;pattern&amp;gt;%date{ISO8601} %-5level %logger{36} %X{sourceThread} - %msg%n&amp;lt;/pattern&amp;gt;--&amp;gt;
            &amp;lt;pattern&amp;gt;%date{ISO8601} %-5level %logger{36} %X{akkaSource} - %msg%n&amp;lt;/pattern&amp;gt;
        &amp;lt;/encoder&amp;gt;
    &amp;lt;/appender&amp;gt;

        &amp;lt;appender name=&amp;quot;STDOUT&amp;quot; class=&amp;quot;ch.qos.logback.core.ConsoleAppender&amp;quot;&amp;gt;
        &amp;lt;encoder&amp;gt;
            &amp;lt;pattern&amp;gt;%date{ISO8601} %-5level %logger{36} %X{akkaSource} - %msg%n&amp;lt;/pattern&amp;gt;
            &amp;lt;!--&amp;lt;pattern&amp;gt;%X{akkaTimestamp} %-5level %logger{36} %X{akkaSource} - %msg%n&amp;lt;/pattern&amp;gt;--&amp;gt;
        &amp;lt;/encoder&amp;gt;
    &amp;lt;/appender&amp;gt;

    &amp;lt;root level=&amp;quot;DEBUG&amp;quot;&amp;gt;
        &amp;lt;appender-ref ref=&amp;quot;STDOUT&amp;quot; /&amp;gt;
        &amp;lt;appender-ref ref=&amp;quot;FILE&amp;quot; /&amp;gt;
    &amp;lt;/root&amp;gt;
&amp;lt;/configuration&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;日志的每种输出方式对应一个appender，除了上面用到的ConsoleAppender和FileAppender，还有通过网络发送日志到远程日志服务器的Appender，用户也可自定义appender，如日志云服务提供商loggly就有自己的&lt;a href=&quot;https://github.com/qos-ch/logback-extensions/wiki/Loggly&quot;&gt;Appender&lt;/a&gt;。分布式消息系统kafka也能通过&lt;a href=&quot;http://kafka.apache.org/07/quickstart.html&quot;&gt;Appender&lt;/a&gt;直接在某个topic上接收log日志。&lt;/p&gt;

&lt;p&gt;更多语法参考：http://logback.qos.ch/manual/appenders.html&lt;/p&gt;

&lt;p&gt;最后推荐一篇LinkedIn工程师关于日志的长文&lt;a href=&quot;https://engineering.linkedin.com/distributed-systems/log-what-every-software-engineer-should-know-about-real-time-datas-unifying&quot;&gt;The Log: What every software engineer should know about real-time data&amp;#39;s unifying abstraction&lt;/a&gt;，当然他说的日志已经超出了简单记录调试信息的范畴了，但其中一些观点很有意思，如数据库其实是一种特殊形式的日志，按照这个思路所谓大数据其实就是如何翻日志了，日志将是整个系统最重要的资产。&lt;/p&gt;

&lt;p&gt;相关代码已提交&lt;a href=&quot;https://github.com/wuhx/akka-logging-example&quot;&gt;github&lt;/a&gt;, 欢迎fork交流。&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>Demo post</title>
        <link>xun.im/2014/03/07/demo-post/</link>
        <pubDate>Fri, 07 Mar 2014 00:00:00 +0800</pubDate>
        <author>wuhx</author>
        <description>&lt;p&gt;Praesent tincidunt vestibulum sem nec eleifend. Pellentesque adipiscing mollis adipiscing. Sed ipsum sem, eleifend eget dapibus in, tincidunt ut dolor. Curabitur gravida urna leo, eget auctor turpis feugiat non. Vivamus pharetra, lorem id ullamcorper rutrum, eros erat condimentum erat, ac dignissim lorem nisi nec nunc. Praesent tellus mi, volutpat quis nisl et, consectetur blandit nibh.&lt;/p&gt;

&lt;p&gt;Nulla sit amet nulla non odio sodales mollis elementum sed sem. Aenean et laoreet enim. Curabitur vulputate, mi rutrum commodo condimentum, enim nunc feugiat magna, vel rutrum sapien ante nec ante. Donec nec nibh placerat, molestie felis ac, vulputate arcu. Donec condimentum pellentesque nibh vel tincidunt. Fusce sem ipsum, varius at laoreet vitae, accumsan sed nisl. Nunc eget viverra diam. Aliquam pulvinar, enim id commodo tincidunt, risus lectus pharetra lacus, et semper enim ligula ut mauris. Sed vitae sollicitudin ante. In sollicitudin placerat dui et sagittis.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit. Maecenas egestas leo id tortor feugiat, sit amet cursus diam mollis. Nunc sit amet tellus est. Nunc lacus nisl, gravida ut aliquam vel, molestie eget odio. Nulla facilisi. Ut sed libero pharetra nunc volutpat hendrerit. Mauris eget mi adipiscing, congue tellus ut, scelerisque eros. Phasellus ullamcorper dictum tellus nec pretium.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Integer molestie orci ante, nec dictum metus aliquam ut. Donec id tristique enim. Quisque tellus est, dignissim ut justo ac, volutpat fringilla mi. Duis ultricies nec sapien vitae blandit. &lt;strong&gt;Suspendisse sed est mi&lt;/strong&gt;. Mauris varius sapien vel nulla accumsan, id tincidunt ipsum ultrices. Sed eget magna mauris. Etiam porttitor lacus ullamcorper lacus tincidunt aliquam. Sed feugiat congue fringilla. Nunc velit diam, vulputate sed metus vitae, iaculis tempor arcu. Proin consectetur a erat in dignissim.&lt;/p&gt;

&lt;table&gt;&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Tables&lt;/th&gt;
&lt;th style=&quot;text-align: center&quot;&gt;Are&lt;/th&gt;
&lt;th style=&quot;text-align: right&quot;&gt;Cool&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;col 3 is&lt;/td&gt;
&lt;td style=&quot;text-align: center&quot;&gt;right-aligned&lt;/td&gt;
&lt;td style=&quot;text-align: right&quot;&gt;$1600&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;col 2 is&lt;/td&gt;
&lt;td style=&quot;text-align: center&quot;&gt;centered&lt;/td&gt;
&lt;td style=&quot;text-align: right&quot;&gt;$12&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;zebra stripes&lt;/td&gt;
&lt;td style=&quot;text-align: center&quot;&gt;are neat&lt;/td&gt;
&lt;td style=&quot;text-align: right&quot;&gt;$1&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;

&lt;p&gt;Pellentesque adipiscing mollis adipiscing.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Nulla sit amet nulla non odio sodales mollis elementum sed sem.&lt;/li&gt;
&lt;li&gt;Donec id tristique enim. Quisque tellus est, dignissim ut justo ac, volutpat fringilla mi.&lt;/li&gt;
&lt;li&gt;Nam luctus erat dolor, non viverra nulla varius at.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Curabitur nec ullamcorper dui, blandit aliquet ipsum. Integer suscipit odio quis eros fermentum auctor. Sed tincidunt quam eleifend, egestas erat vulputate, tincidunt metus. Maecenas gravida sodales mi nec posuere. Cras vel nisi condimentum, hendrerit lacus sed, scelerisque ipsum. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Nunc convallis vestibulum erat, quis porta tellus. &lt;em&gt;In lorem erat, sollicitudin varius posuere id, molestie ac eros&lt;/em&gt;. Fusce luctus tellus vitae vulputate venenatis. Sed scelerisque bibendum interdum. Sed pretium commodo ultrices. Fusce luctus quam id porttitor vulputate. Integer ornare consectetur diam eget rutrum. Etiam eget sapien metus.&lt;/p&gt;

&lt;dl&gt;  &lt;dt&gt;Ornare&lt;/dt&gt;  &lt;dd&gt;Cras vel nisi condimentum, hendrerit lacus sed, scelerisque ipsum.&lt;/dd&gt;  &lt;dt&gt;Convallis&lt;/dt&gt;  &lt;dd&gt;In lorem erat, sollicitudin varius posuere id, molestie ac eros&lt;/dd&gt;&lt;/dl&gt;

&lt;p&gt;Proin at libero id lorem fermentum elementum quis eget est.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Nam bibendum turpis massa, at accumsan justo fermentum ac.&lt;/li&gt;
&lt;li&gt;Nulla non nulla ut ante condimentum mattis vel at lectus.&lt;/li&gt;
&lt;li&gt;Etiam eget tortor tincidunt, iaculis ligula a, tristique massa. Fusce sed congue lorem, interdum sodales nisl.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Etiam consequat euismod ornare. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Nulla pellentesque ipsum vulputate, pellentesque nisl vitae, lacinia sem. Praesent auctor felis et odio ultrices, nec tempor elit lobortis. Etiam ornare massa non risus luctus, id iaculis lacus egestas. Pellentesque massa dolor, mattis id lobortis eget, tristique vitae est.&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;Nam vulputate leo vitae libero vehicula, id tincidunt velit malesuada. In vel ornare nisi, id semper turpis. Vivamus erat elit, venenatis quis dui at, convallis suscipit sapien. Nunc in nisi scelerisque, aliquam mauris porttitor, facilisis ligula. Vestibulum cursus erat ac turpis bibendum, id pulvinar dolor dapibus. Proin vitae justo et velit imperdiet ultrices id id odio. Cras adipiscing ante vel mauris lobortis rutrum. Aenean eu felis est. In lacinia porttitor risus non sagittis.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;class Greeter
  def initialize(message)
    @message = message
  end

  def greet
    puts message
  end
end

john = Greeter.new &amp;#39;Hello, World&amp;#39;

john.greet
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Sed imperdiet interdum ultrices. Phasellus iaculis porttitor lorem nec scelerisque. Suspendisse eros urna, adipiscing vel luctus at, feugiat sit amet arcu. Aliquam porttitor ut urna pellentesque sagittis. Donec pellentesque venenatis diam sit amet cursus. Etiam luctus, metus quis gravida fermentum, tortor arcu consequat metus, eget viverra augue risus ac dui. Fusce faucibus scelerisque quam eu sagittis. Sed sit amet sapien non augue lobortis adipiscing. Sed sagittis at lectus eu tempus. Nulla non nulla ut ante condimentum mattis vel at lectus. Nulla ultricies dui et urna semper ultrices. Sed neque ante, dictum in dignissim luctus, facilisis ornare odio. Aenean tempor ultrices magna non pharetra. Curabitur vulputate nec est aliquet suscipit. Etiam ipsum sapien, dictum quis tristique vel, pretium at elit.&lt;/p&gt;
</description>
      </item>
    

  </channel>
</rss>
