<?xml version="1.0"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Not my idea</title>
    <link>xun.im</link>
    <atom:link href="xun.im/feed.xml" rel="self" type="application/rss+xml" />
    <description>personal blog, scala, akka,</description>
    <language>en-us</language>
    <pubDate>Mon, 27 Apr 2015 16:03:21 +0800</pubDate>
    <lastBuildDate>Mon, 27 Apr 2015 16:03:21 +0800</lastBuildDate>

    
      <item>
        <title>scala的implicit和magnet模式</title>
        <link>xun.im/2015/04/21/scala-implicit-and-magnet-pattern/</link>
        <pubDate>Tue, 21 Apr 2015 00:00:00 +0800</pubDate>
        <author>wuhx</author>
        <description>&lt;p&gt;对初学scala的人，implicit像一个黑魔法，来无影去无踪，像它的名字一样非常“含蓄”。&lt;/p&gt;

&lt;p&gt;从某种意义上讲，implicit是一个类型系统的游戏。scala是强类型系统，所有的参数都需要符合类型预期，如果需要一个Int类型，你传来一个String，编译器会报类型不符错误。implicit的引入，使在报错之前还有一次机会，即：如果编译器在当前作用域内找到一个从String转换到Int的implicit定义函数，编译器会用这个implicit把你传给它的String转换成它需要的Int，于是一切又愉快的发生下去了。&lt;/p&gt;

&lt;p&gt;当然这只是implicit的一种使用场景，spray.io（已合并到akka-http）的magnet模式利用的就是这个特性。&lt;/p&gt;

&lt;h2&gt;magnet模式&lt;/h2&gt;

&lt;p&gt;magnet模式简单讲就是通过定义一个magnet类型作为统一的参数，然后针对需要重载的参数列表，类型等，在magnet类型的companion object中实现相应的转换为magnet类型的implitcit函数。&lt;/p&gt;

&lt;p&gt;如：可以定义一个Magnet类型实现一个接受任意参数的add函数&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;def add(magnet: MyMagnet): magnet.Result = magnet()

sealed trait MyMagnet {
  type Result
  def apply(): Result
}

object MyMagnet {
  //一个整形参数到MyMagenet的转换
  implicit def fromInt(i: Int) =
    new MyMagnet {
      type Result = Int
      def apply(): Result = i + 1
    }
  //一个String参数到MyMagenet的转换
  implicit def fromString(s: String) =
    new MyMagnet {
      type Result = String
      def apply(): Result = &amp;quot;hello &amp;quot; + s
    }
  //一个String参数加一个整形参数到MyMagenet的转换
  implicit def fromStringAndInt(tuple: (String, Int)) =
    new MyMagnet {
      type Result = String
      def apply(): Result = tuple._1 + tuple._2.toString
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;调用的时候可以：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;scala&amp;gt; add(1)
res9: Int = 2

scala&amp;gt; add(&amp;quot;world&amp;quot;)
res10: String = hello world

scala&amp;gt; add(&amp;quot;happy string &amp;quot;, 5)
res11: String = happy string 5
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;看到这里，你可能会说这不就是重载吗？java和scala原生就支持重载，但jvm对泛型（generics）的支持是通过类型擦除（type erasure）实现的，这意味着java常规的重载无法带类型参数，如：jvm无法区分下面这种类型不同的List参数。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;scala&amp;gt; :paste
// Entering paste mode (ctrl-D to finish)

def add(a: List[Int]): Unit = {}
def add(a: List[String]): Unit = {}

// Exiting paste mode, now interpreting.

&amp;lt;console&amp;gt;:8: error: double definition:
def add(a: List[Int]): Unit at line 7 and
def add(a: List[String]): Unit at line 8
have same type after erasure: (a: List)Unit
def add(a: List[String]): Unit = {}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;而magnet模式正好可以弥补这个缺憾，另外magnet模式相当于把重载的实现从语言层面拉到了自己的代码逻辑中，有利于针对性的引入一些新技巧减少冗余代码。当然，magnet的缺点也是很明显的：额外的一层增加了代码的复杂度。&lt;/p&gt;

&lt;h3&gt;隐含参数&lt;/h3&gt;

&lt;p&gt;implicit另外一个常用的场景是： 替代全局变量，作为某个执行上下文中的隐含参数。&lt;/p&gt;

&lt;p&gt;如：scala中异步的一个重要方法是使用Future。Futrure语义清晰，使用优雅，比手动起线程不知道高到哪里去了；），但Future在后台其实还是通过线程来执行的，要用Future就需要一个指定的执行上下文环境（&lt;a href=&quot;http://www.scala-lang.org/api/2.11.6/index.html#scala.concurrent.ExecutionContext&quot;&gt;ExecutionContext&lt;/a&gt; ，一般是线程池）来跑Future。Future又是一个object（单例对象，不是普通类）没有地方放这个线程池的引用，解决方案只能是在所有Future的方法中加上ExecutionContext参数，方法很函数式，但接口略显冗余。好在scala有implicit，只要你调用Future时，上下文中有一个implicit的ExecutionContext变量，Future会自动在这个EC上跑代码。&lt;/p&gt;

&lt;p&gt;所以scala的&lt;a href=&quot;http://www.scala-lang.org/files/archive/nightly/docs/library/index.html#scala.concurrent.Future&quot;&gt;Future&lt;/a&gt;方法都有一个(implicit executor: ExecutionContext)参数&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;def onComplete(U ⇒ U)(implicit executor: ExecutionContext): Unit
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;不同于全局变量，你在调用Future方法时，想使用某个指定的ExecutionContext，还是可以把它作为参数显示的传递给Future方法，这个显示传递的参数会覆盖implicit的参数。&lt;/p&gt;

&lt;p&gt;另：ExecutionContext的获取方法有&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;直接引用全局EC。&lt;code&gt;import scala.concurrent.ExecutionContext.Implicits.global&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;akka的actor中，引用当前actor系统的EC。&lt;code&gt;import context.dispatcher&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;也可以手动创建一个独占使用，确保线程池里的线程不会被其他不相干任务耗尽。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;   import java.util.concurrent.Executors
   import concurrent.ExecutionContext
   //创建一个4个线程的线程池
   val executorService = Executors.newFixedThreadPool(4)
   implicit val ec = ExecutionContext.fromExecutorService(executorService)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;更多相关资料：&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://spray.io/blog/2012-12-13-the-magnet-pattern/&quot;&gt;The magnet pattern&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://pavelfatin.com/design-patterns-in-scala/&quot;&gt;Design Patterns in Scala&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://eed3si9n.com/revisiting-implicits-without-import-tax&quot;&gt;revisiting implicits without import tax&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.artima.com/pins1ed/implicit-conversions-and-parameters.html&quot;&gt;Chapter 21 of Programming in Scala, First Edition&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://ropas.snu.ac.kr/%7Ebruno/papers/TypeClasses.pdf&quot;&gt;Type Classes as Objects and Implicits&lt;/a&gt; &lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>AKKA的日志： slf4j，logback和其他</title>
        <link>xun.im/2015/04/15/akka-logging/</link>
        <pubDate>Wed, 15 Apr 2015 00:00:00 +0800</pubDate>
        <author>wuhx</author>
        <description>&lt;p&gt;作为一个“搞kernel的”，对日志的理解不过是printk的EMERG,INFO,DEBUG等各种level，关键时刻还是得dump内存，上gcc单步跟踪。但在到处是异步并发，远程分布式通信的jdk世界，日志成了定位问题最重要甚至是唯一的手段。在akka上尤为如此。&lt;/p&gt;

&lt;p&gt;akka日志的官方文档&lt;a href=&quot;http://doc.akka.io/docs/akka/current/scala/logging.html&quot;&gt;http://doc.akka.io/docs/akka/current/scala/logging.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;akka日志功能是基于slf4j构建的。对于不熟悉java的人，slf4j，log4j，logback等基本上是这样一个关系：SLF4J是一套log接口，java.util.logging, logback, log4j等是具体的实现，而logback已逐渐取代log4j成为事实标准。&lt;/p&gt;

&lt;p&gt;所以要使用akka的日志，除了akka-slf4j还需增加logback依赖。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;libraryDependencies ++= Seq(
  &amp;quot;com.typesafe.akka&amp;quot; %% &amp;quot;akka-actor&amp;quot; % akkaVersion,
  &amp;quot;com.typesafe.akka&amp;quot; %% &amp;quot;akka-contrib&amp;quot; % akkaVersion,
  &amp;quot;com.typesafe.akka&amp;quot; %% &amp;quot;akka-testkit&amp;quot; % akkaVersion,
  &amp;quot;com.typesafe.akka&amp;quot; %% &amp;quot;akka-slf4j&amp;quot; % akkaVersion,
  &amp;quot;org.scalatest&amp;quot; %% &amp;quot;scalatest&amp;quot; % &amp;quot;2.2.4&amp;quot; % &amp;quot;test&amp;quot;,
  &amp;quot;ch.qos.logback&amp;quot; % &amp;quot;logback-classic&amp;quot; % &amp;quot;1.1.3&amp;quot;,
  &amp;quot;commons-io&amp;quot; % &amp;quot;commons-io&amp;quot; % &amp;quot;2.4&amp;quot; % &amp;quot;test&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;actor系统中记录日志的三种方法&lt;/h2&gt;

&lt;h3&gt;1 通过ActorLogging记录日志&lt;/h3&gt;

&lt;p&gt;akka提供了ActorLogging这个trait，方便在actor中记录日志。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;class MasterActor extends Actor with akka.actor.ActorLogging{
  def receive = {
    case _ =&amp;gt;
     log.debug(&amp;quot;debug log&amp;quot;)
     log.info(&amp;quot;info log&amp;quot;)
     log.warning(&amp;quot;warning log&amp;quot;)
     log.error(&amp;quot;error log&amp;quot;)
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;2 通过akka.event.Logging记录日志　&lt;/h3&gt;

&lt;p&gt;ActorLogging这个trait只能mix到Actor类上。&lt;/p&gt;

&lt;p&gt;在其他非actor类上，如果能访问到actor系统，可利用它的event stream进行log。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;import akka.event.Logging
val log = Logging(system.eventStream, &amp;quot;log prefix:&amp;quot;)
log.debug(&amp;quot;debug log&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;也可直接使用ActorSystem内置的LoggingAdapter。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;val system = akka.actor.ActorSystem()
system.log.error(&amp;quot;log from ActorSystem&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3 直接通过slf4j访问logback记录日志&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;import org.slf4j.LoggerFactory
val log = LoggerFactory.getLogger(getClass)
log.debug(&amp;quot;Hello Logger!&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这3种log方式因为用的都是同一个logback实例，所以输出是统一的，区别是akka提供的log接口能够在记录时自动带上actor地址等信息，能极大的方便定位问题。&lt;/p&gt;

&lt;h2&gt;logback的配置&lt;/h2&gt;

&lt;p&gt;上面说了半天好像和printk的level级别没有太大差别，java的log系统最强大的地方在于它的可配置性。&lt;/p&gt;

&lt;p&gt;如下面这个logback配置，可把ERROR及以上级别的打印输出到akka.log文件，同时把DEBUG及以上级别的打印输出到控制台。还可以配置输出格式，自动在log内容上附带一些上下文信息，如&lt;code&gt;%X{akkaSource}&lt;/code&gt;这个变量会解析为发起log的具体actor地址，这在系统上百万actor并发时，将成为跟踪问题重要线索。如果输出到日志文件，还可控制文件体积的最大值，选择原有内容是追加还是覆盖。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-xml&quot; data-lang=&quot;xml&quot;&gt;&amp;lt;configuration&amp;gt;
        &amp;lt;appender name=&amp;quot;FILE&amp;quot; class=&amp;quot;ch.qos.logback.core.FileAppender&amp;quot;&amp;gt;
        &amp;lt;file&amp;gt;akka.log&amp;lt;/file&amp;gt;
        &amp;lt;filter class=&amp;quot;ch.qos.logback.classic.filter.ThresholdFilter&amp;quot;&amp;gt;
            &amp;lt;level&amp;gt;ERROR&amp;lt;/level&amp;gt;
        &amp;lt;/filter&amp;gt;
        &amp;lt;append&amp;gt;false&amp;lt;/append&amp;gt;
        &amp;lt;!-- encoders are assigned the type
             ch.qos.logback.classic.encoder.PatternLayoutEncoder by default --&amp;gt;
        &amp;lt;encoder&amp;gt;
            &amp;lt;!--&amp;lt;pattern&amp;gt;%date{ISO8601} %-5level %logger{36} %X{sourceThread} - %msg%n&amp;lt;/pattern&amp;gt;--&amp;gt;
            &amp;lt;pattern&amp;gt;%date{ISO8601} %-5level %logger{36} %X{akkaSource} - %msg%n&amp;lt;/pattern&amp;gt;
        &amp;lt;/encoder&amp;gt;
    &amp;lt;/appender&amp;gt;

        &amp;lt;appender name=&amp;quot;STDOUT&amp;quot; class=&amp;quot;ch.qos.logback.core.ConsoleAppender&amp;quot;&amp;gt;
        &amp;lt;encoder&amp;gt;
            &amp;lt;pattern&amp;gt;%date{ISO8601} %-5level %logger{36} %X{akkaSource} - %msg%n&amp;lt;/pattern&amp;gt;
            &amp;lt;!--&amp;lt;pattern&amp;gt;%X{akkaTimestamp} %-5level %logger{36} %X{akkaSource} - %msg%n&amp;lt;/pattern&amp;gt;--&amp;gt;
        &amp;lt;/encoder&amp;gt;
    &amp;lt;/appender&amp;gt;

    &amp;lt;root level=&amp;quot;DEBUG&amp;quot;&amp;gt;
        &amp;lt;appender-ref ref=&amp;quot;STDOUT&amp;quot; /&amp;gt;
        &amp;lt;appender-ref ref=&amp;quot;FILE&amp;quot; /&amp;gt;
    &amp;lt;/root&amp;gt;
&amp;lt;/configuration&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;日志的每种输出方式对应一个appender，除了上面用到的ConsoleAppender和FileAppender，还有通过网络发送日志到远程日志服务器的Appender，用户也可自定义appender，如日志云服务提供商loggly就有自己的&lt;a href=&quot;https://github.com/qos-ch/logback-extensions/wiki/Loggly&quot;&gt;Appender&lt;/a&gt;。分布式消息系统kafka也能通过&lt;a href=&quot;http://kafka.apache.org/07/quickstart.html&quot;&gt;Appender&lt;/a&gt;直接在某个topic上接收log日志。&lt;/p&gt;

&lt;p&gt;更多语法参考：http://logback.qos.ch/manual/appenders.html&lt;/p&gt;

&lt;p&gt;最后推荐一篇LinkedIn工程师关于日志的长文&lt;a href=&quot;https://engineering.linkedin.com/distributed-systems/log-what-every-software-engineer-should-know-about-real-time-datas-unifying&quot;&gt;The Log: What every software engineer should know about real-time data&amp;#39;s unifying abstraction&lt;/a&gt;，当然他说的日志已经超出了简单记录调试信息的范畴了，但其中一些观点很有意思，如数据库其实是一种特殊形式的日志，按照这个思路所谓大数据其实就是如何翻日志了，日志将是整个系统最重要的资产。&lt;/p&gt;

&lt;p&gt;相关代码已提交&lt;a href=&quot;https://github.com/wuhx/akka-logging-example&quot;&gt;github&lt;/a&gt;, 欢迎fork交流。&lt;/p&gt;
</description>
      </item>
    

  </channel>
</rss>
